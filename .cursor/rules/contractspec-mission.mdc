---
alwaysApply: true
---

# ContractSpec Mission & Context

"AI must understand the core mission and vision of ContractSpec to make informed decisions about features, DX, and technical architecture. Every choice should serve the goal of compiling intents into customized, personalized, auto-evolutive codebases."

---

## Mission Statement

**ContractSpec compiles intents into a customized & personalized, auto-evolutive codebase.**

---

## Core Value Proposition

### Goal

Transform high-level intents and specifications into fully functional, multi-platform code that evolves automatically as requirements change. No more glue code, no more boilerplate — just declare what you want, and ContractSpec makes it happen.

### How We Do It

1. **Spec-First Definition**: Define operations, events, and presentations in pure TypeScript using `defineCommand`, `defineQuery`, and `defineEvent`.
2. **Runtime Adapters**: The spec _is_ the code. Runtime adapters (REST, GraphQL, MCP, UI) automatically generate endpoints, schemas, and interfaces without code duplication.
3. **Auto-Evolution**: As your product evolves, ContractSpec suggests and applies improvements automatically, keeping your codebase aligned with best practices.
4. **Lifecycle Management**: Track and guide users through product adoption with ceremonies, milestones, and personalized recommendations.

### Who It's For

**Developers and teams building modern, AI-first products** who want to:

- Ship faster without sacrificing quality
- Maintain a single source of truth for their API contracts
- Automatically generate multi-platform adapters
- Let their codebase evolve intelligently over time

**In short:** _"From intent to production-ready code, with auto-evolution built in."_

---

## Principles

### 1. Spec-First, Code-Second

The specification is the source of truth. Code is generated from specs, not the other way around. This ensures consistency across platforms and eliminates drift between documentation and implementation.

### 2. Intent Over Implementation

Focus on _what_ you want to achieve, not _how_ to implement it. ContractSpec handles the implementation details, allowing developers to work at a higher level of abstraction.

### 3. Auto-Evolution as Default

Codebases should improve over time without manual intervention. ContractSpec monitors patterns, suggests optimizations, and applies improvements automatically when appropriate.

### 4. Composable by Design

Everything is a building block. Specs, adapters, and components are designed to be composed, extended, and reused across projects and platforms.

### 5. Multi-Platform from One Source

Define once, deploy everywhere. A single spec generates REST APIs, GraphQL schemas, MCP tools for AI agents, and type-safe client SDKs — all from one definition.

### 6. Observability Built-In

Every operation is traceable, measurable, and debuggable by default. No additional instrumentation required — observability is part of the spec.

---

## Target User Archetypes

### Archetype 1: The AI-First Developer

- **Profile:** Building products with AI agents, LLMs, and conversational interfaces
- **Pain Points:** Exposing APIs to AI agents requires custom MCP servers, prompt engineering complexity, inconsistent tool definitions
- **Needs:** Automatic MCP adapter generation, type-safe tool definitions, AI-native observability

### Archetype 2: The Startup/Indie Hacker

- **Profile:** Solo founder or small team shipping fast with limited resources
- **Pain Points:** Too much boilerplate, maintaining consistency across frontend/backend, documentation drift
- **Needs:** Rapid prototyping, automatic API generation, zero-config deployment

### Archetype 3: The Platform Team

- **Profile:** Engineering team responsible for standardizing APIs and contracts across the organization
- **Pain Points:** Inconsistent API designs, duplicated validation logic, schema drift between services
- **Needs:** Centralized contract definitions, automated compliance checks, cross-team consistency

### Archetype 4: The Enterprise Team

- **Profile:** Large team prioritizing maintainability, security, and governance
- **Pain Points:** Technical debt accumulation, onboarding complexity, audit trails
- **Needs:** Auto-evolution with guardrails, comprehensive audit logging, lifecycle governance

---

## Design & Development Heuristics

### Feature Design

✅ Does this feature reduce boilerplate for developers?
✅ Does it follow the spec-first philosophy?
✅ Is the output automatically generated from the spec, not manually maintained?
✅ Does it work across all runtime adapters (REST, GraphQL, MCP)?
✅ Does it handle evolution gracefully (backwards compatibility, migrations)?
❌ Does this feature require developers to write glue code?
❌ Is this implementation-first rather than spec-first?

### DX & Messaging

✅ Is the API intuitive and self-documenting?
✅ Can a developer understand what a spec does without reading implementation code?
✅ Are error messages clear and actionable?
✅ Does the CLI provide helpful guidance and suggestions?
✅ Does the experience feel like "declaring intent" rather than "writing code"?
❌ Are we requiring excessive configuration?
❌ Are we exposing internal complexity to the developer?

### AI Behavior (for ContractSpec Studio)

✅ Is the AI suggesting improvements based on the spec's intent?
✅ Does the AI explain its evolution suggestions in simple terms?
✅ Is the AI connecting patterns across different specs?
✅ Does the AI adapt its recommendations as the project evolves?
✅ Is the AI transparent about what changes it will make?
❌ Is the AI making changes without clear justification?
❌ Is the AI using technical jargon without explanation?

### Technical Architecture

✅ Is this logic expressed in the spec, not in adapter-specific code?
✅ Can this be reused across different runtime adapters?
✅ Is observability automatic, not opt-in?
✅ Can the system handle schema evolution gracefully?
✅ Are we building for extensibility without over-engineering?
❌ Are we building adapter-specific features that can't be generalized?
❌ Are we making architectural choices that lock developers into specific platforms?

---

## Competitive Differentiation

**We are NOT:**

- A code generator like Swagger/OpenAPI codegen (generates once, then you maintain)
- A schema-first tool like Prisma (database-centric, not API-centric)
- A GraphQL-only solution like Hasura (single protocol, not multi-platform)
- A no-code platform (we're for developers, not non-technical users)

**We ARE:**

- A spec-first platform where the spec _is_ the runtime
- A multi-platform adapter generator from a single source of truth
- An auto-evolutive system that improves your codebase over time
- A developer tool that feels like "declaring intent" rather than "writing code"

---

## Competitive Landscape & Inspirations

### Strategic Positioning

**Market Focus:** Developer-first, spec-first tooling for modern AI-first products

**Technical Advantage:** Runtime adapters that don't require code generation — the spec is directly interpretable at runtime, eliminating drift between definition and implementation.

### Inspirational References

#### Prisma — Schema-First Inspiration

Type-safe database client generated from schema. Clear separation between definition (schema.prisma) and implementation.

**What we emulate:** Schema-first philosophy, type safety, excellent DX, clear mental model.

**How we differentiate:** API-centric (not database-centric), multi-platform (not just ORM), runtime adapters (not compile-time generation).

#### tRPC — Type Safety Inspiration

End-to-end type safety without code generation. Procedure-based API definition.

**What we emulate:** Zero-config type safety, procedure-based thinking, excellent TypeScript integration.

**How we differentiate:** Multi-protocol (REST, GraphQL, MCP), spec includes metadata (owners, stability, observability), auto-evolution.

#### Swagger/OpenAPI — Contract-First Inspiration

Industry standard for API documentation and code generation.

**What we emulate:** Contract-first thinking, comprehensive documentation, ecosystem support.

**How we differentiate:** TypeScript-native (not YAML), runtime adapters (not codegen), includes business logic (not just schema).

#### Anthropic MCP — AI Integration Inspiration

Model Context Protocol for AI agent tool definitions.

**What we emulate:** Structured tool definitions for AI, type-safe parameter schemas.

**How we differentiate:** Unified definition (same spec powers REST, GraphQL, and MCP), automatic adapter generation.

### Market Opportunity

**Gap in Market:** No platform combines spec-first API definition with multi-platform runtime adapters AND auto-evolution. Existing tools either generate code (requiring maintenance) or are locked to single protocols.

**ContractSpec's Position:** Spec-first, TypeScript-native, multi-platform runtime adapters with auto-evolution built in.

---

## Key Concepts

### ContractSpec

A unified specification that defines operations (commands/queries), events, and presentations. The spec is the single source of truth for all runtime behavior.

### Runtime Adapters

Platform-specific interpreters that read specs and expose them as APIs:
- **REST Adapter**: Exposes specs as REST endpoints
- **GraphQL Adapter**: Generates GraphQL schema from specs
- **MCP Adapter**: Exposes specs as AI agent tools

### Auto-Evolution

The system's ability to monitor usage patterns, detect improvements, and apply them automatically. Evolution is tracked, reversible, and explainable.

### Lifecycle Management

Tracking where a user/project is in their journey and providing contextual guidance, ceremonies (meaningful transitions), and recommendations.

---

## References

- See `docs/` for detailed technical documentation
- See `examples/` for implementation patterns
- See `code-organization.mdc` for package structure and dependency rules
- See `packages/libs/contracts/README.md` for core contract definitions
