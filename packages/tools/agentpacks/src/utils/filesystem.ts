import {
  existsSync,
  mkdirSync,
  readFileSync,
  writeFileSync,
  readdirSync,
  rmSync,
  statSync,
} from 'fs';
import { dirname, relative, join } from 'path';

/** Header comment for generated files. */
const GENERATED_HEADER_MD = '<!-- Generated by agentpacks. DO NOT EDIT. -->';
const GENERATED_HEADER_JSON = '// Generated by agentpacks. DO NOT EDIT.';
const GENERATED_HEADER_JS = '// Generated by agentpacks. DO NOT EDIT.';

/**
 * Write a file with the generated header comment.
 * Creates parent directories as needed.
 */
export function writeGeneratedFile(
  filepath: string,
  content: string,
  options: { header?: boolean; type?: 'md' | 'json' | 'js' | 'ts' } = {}
): void {
  const { header = true, type } = options;
  const ext = type ?? inferFileType(filepath);

  ensureDir(dirname(filepath));

  let output = content;
  if (header) {
    const headerComment = getHeader(ext);
    if (headerComment) {
      output = `${headerComment}\n${content}`;
    }
  }

  writeFileSync(filepath, output, 'utf-8');
}

/**
 * Write a JSON file with optional generated header.
 */
export function writeGeneratedJson(
  filepath: string,
  data: unknown,
  options: { header?: boolean } = {}
): void {
  const json = JSON.stringify(data, null, 2);
  writeGeneratedFile(filepath, json + '\n', { ...options, type: 'json' });
}

/**
 * Read a file as string, or return null if it doesn't exist.
 */
export function readFileOrNull(filepath: string): string | null {
  if (!existsSync(filepath)) return null;
  return readFileSync(filepath, 'utf-8');
}

/**
 * Read and parse a JSON file, or return null if it doesn't exist.
 */
export function readJsonOrNull<T = unknown>(filepath: string): T | null {
  const content = readFileOrNull(filepath);
  if (content === null) return null;
  return JSON.parse(content) as T;
}

/**
 * Ensure a directory exists, creating it recursively if needed.
 */
export function ensureDir(dirPath: string): void {
  if (!existsSync(dirPath)) {
    mkdirSync(dirPath, { recursive: true });
  }
}

/**
 * Remove a directory or file if it exists.
 */
export function removeIfExists(targetPath: string): void {
  if (existsSync(targetPath)) {
    rmSync(targetPath, { recursive: true, force: true });
  }
}

/**
 * List all files in a directory matching a filter.
 */
export function listFiles(
  dirPath: string,
  options: { extension?: string; recursive?: boolean } = {}
): string[] {
  const { extension, recursive = false } = options;

  if (!existsSync(dirPath)) return [];

  const results: string[] = [];
  const entries = readdirSync(dirPath);

  for (const entry of entries) {
    const fullPath = join(dirPath, entry);
    const stat = statSync(fullPath);

    if (stat.isDirectory() && recursive) {
      results.push(...listFiles(fullPath, options));
    } else if (stat.isFile()) {
      if (!extension || entry.endsWith(extension)) {
        results.push(fullPath);
      }
    }
  }

  return results;
}

/**
 * List subdirectories in a directory.
 */
export function listDirs(dirPath: string): string[] {
  if (!existsSync(dirPath)) return [];

  return readdirSync(dirPath)
    .map((entry) => join(dirPath, entry))
    .filter((fullPath) => statSync(fullPath).isDirectory());
}

/**
 * Get relative path from project root.
 */
export function relPath(projectRoot: string, filepath: string): string {
  return relative(projectRoot, filepath);
}

/**
 * Check if a path is a generated file by looking for the header.
 */
export function isGeneratedFile(filepath: string): boolean {
  const content = readFileOrNull(filepath);
  if (!content) return false;
  return (
    content.startsWith(GENERATED_HEADER_MD) ||
    content.startsWith(GENERATED_HEADER_JSON) ||
    content.startsWith(GENERATED_HEADER_JS)
  );
}

function inferFileType(filepath: string): 'md' | 'json' | 'js' | 'ts' {
  if (filepath.endsWith('.json') || filepath.endsWith('.jsonc')) return 'json';
  if (filepath.endsWith('.ts') || filepath.endsWith('.mts')) return 'ts';
  if (filepath.endsWith('.js') || filepath.endsWith('.mjs')) return 'js';
  return 'md';
}

function getHeader(type: 'md' | 'json' | 'js' | 'ts'): string | null {
  switch (type) {
    case 'md':
      return GENERATED_HEADER_MD;
    case 'json':
      return GENERATED_HEADER_JSON;
    case 'js':
    case 'ts':
      return GENERATED_HEADER_JS;
    default:
      return null;
  }
}
