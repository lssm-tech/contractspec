import type { DocBlock } from '@contractspec/lib.contracts-spec/docs';
import { registerDocBlocks } from '../../docs/registry';

export const tech_contracts_app_config_DocBlocks: DocBlock[] = [
  {
    id: 'docs.tech.contracts.app-config',
    title: 'App Configuration Layers',
    summary: 'App orchestration is split into three explicit layers:',
    kind: 'reference',
    visibility: 'public',
    route: '/docs/tech/contracts/app-config',
    tags: ['tech', 'contracts', 'app-config'],
    body: "## App Configuration Layers\n\nApp orchestration is split into three explicit layers:\n\n1. **AppBlueprintSpec** \u2013 global, versioned description of what an app can look like. Stored in Git, no tenant/environment data.\n2. **TenantAppConfig** \u2013 tenant/environment overrides that the future Studio edits. Stored per tenant (DB/contract), mutable at runtime.\n3. **ResolvedAppConfig** \u2013 pure, merged view consumed by the runtime. Derived in-memory from a blueprint + tenant config.\n\n- Types & registry: `packages/libs/contracts/src/app-config/spec.ts`\n- Resolution helpers: `packages/libs/contracts/src/app-config/runtime.ts`\n- CLI wizard (blueprint scaffolding): `contractspec create app-config`\n\n### 1. AppBlueprintSpec\n\n```ts\nexport interface AppBlueprintSpec {\n  meta: AppBlueprintMeta;          // { name, version, appId, ownership }\n  capabilities?: { enabled?: CapabilityRef[]; disabled?: CapabilityRef[] };\n  features?: { include?: FeatureRef[]; exclude?: FeatureRef[] };\n  integrationSlots?: AppIntegrationSlot[];\n  branding?: BrandingDefaults;\n  dataViews?: Record<string, SpecPointer>;\n  workflows?: Record<string, SpecPointer>;\n  policies?: PolicyRef[];\n  theme?: AppThemeBinding;\n  telemetry?: TelemetryBinding;\n  experiments?: { active?: ExperimentRef[]; paused?: ExperimentRef[] };\n  featureFlags?: FeatureFlagState[];\n  routes?: AppRouteConfig[];\n  notes?: string;\n}\n```\n\nRegister blueprints with `AppBlueprintRegistry`. Blueprints only capture the default/global experience.\n\n- **Integration slots** declare the categories and capability requirements an app expects (e.g. `\"primary-payments\"` must be a payments provider that supports managed or BYOK credentials). Slots never include secrets; tenants bind concrete connections later.\n- **Branding defaults** provide message-key based names, placeholder assets, and theme token references that downstream tenants can override.\n\n### 2. TenantAppConfig\n\n```ts\nexport interface TenantAppConfig {\n  meta: TenantAppConfigMeta;  // { id, tenantId, appId, blueprintName/version, environment?, version, timestamps }\n  capabilities?: { enable?: CapabilityRef[]; disable?: CapabilityRef[] };\n  features?: { include?: FeatureRef[]; exclude?: FeatureRef[] };\n  dataViewOverrides?: TenantSpecOverride[];\n  workflowOverrides?: TenantSpecOverride[];\n  additionalPolicies?: PolicyRef[];\n  themeOverride?: { primary?: ThemeRef | null; fallbacks?: ThemeRef[] };\n  telemetryOverride?: { spec?: SpecPointer | null; disabledEvents?: string[] };\n  experiments?: { active?: ExperimentRef[]; paused?: ExperimentRef[] };\n  featureFlags?: FeatureFlagState[];\n  routeOverrides?: TenantRouteOverride[];\n  integrations?: AppIntegrationBinding[];\n  knowledge?: AppKnowledgeBinding[];\n  branding?: TenantBrandingConfig;\n  notes?: string;\n}\n```\n\nThis object represents what a tenant edits via the Studio (stored in DB/contracts later).\n\n- **AppIntegrationBinding** now maps `slotId` \u2192 `connectionId` (plus optional workflow scopes). It no longer carries capability lists; those are defined once in the slot.\n- **TenantBrandingConfig** allows per-tenant names, assets, and domain overrides while keeping secrets and large files out of blueprints.\n\n### 3. ResolvedAppConfig\n\n```ts\nexport interface ResolvedAppConfig {\n  appId: string;\n  tenantId: string;\n  environment?: string;\n  blueprintName: string;\n  blueprintVersion: number;\n  configVersion: number;\n  capabilities: { enabled: CapabilityRef[]; disabled: CapabilityRef[] };\n  features: { include: FeatureRef[]; exclude: FeatureRef[] };\n  dataViews: Record<string, SpecPointer>;\n  workflows: Record<string, SpecPointer>;\n  policies: PolicyRef[];\n  theme?: AppThemeBinding;\n  telemetry?: TelemetryBinding;\n  experiments: { catalog: ExperimentRef[]; active: ExperimentRef[]; paused: ExperimentRef[] };\n  featureFlags: FeatureFlagState[];\n  routes: AppRouteConfig[];\n  integrations: ResolvedIntegration[];\n  knowledge: ResolvedKnowledge[];\n  branding: ResolvedBranding;\n  notes?: string;\n}\n```\n\nUse `resolveAppConfig(blueprint, tenant)` to produce this merged view. No IO, no registry lookups\u2014pure data merge.\n\n- `resolveAppConfig` validates slot/category/mode constraints when `integrationConnections` and `integrationSpecs` are provided.\n- `branding` merges blueprint defaults with tenant overrides, producing a runtime-friendly shape (resolved asset URLs, color values, and effective domain).\n\n### Materializing specs\n\n`composeAppConfig(blueprint, tenant, registries, { strict })`:\n\n1. Calls `resolveAppConfig` to build the merged pointers.\n2. Looks up referenced specs in the provided registries.\n3. Returns:\n   - `resolved` \u2013 the merged pointer view\n   - `capabilities`, `features`, `dataViews`, `workflows`, `policies`, `theme`, `telemetry`, `experiments`\n   - `missing` \u2013 unresolved references (strict mode throws).\n\n```ts\nconst blueprint = blueprintRegistry.get('core.app', 1)!;\nconst tenant = loadTenantConfigFromDB();\n\nconst composition = composeAppConfig(blueprint, tenant, {\n  capabilities,\n  features,\n  dataViews,\n  workflows,\n  policies,\n  themes,\n  telemetry,\n  experiments,\n});\n\nif (composition.missing.length) {\n  console.warn('Unresolved references', composition.missing);\n}\n```\n\n### CLI workflow\n\n```\ncontractspec create app-config\n```\n\nGenerates an `AppBlueprintSpec`. A separate flow will later scaffold tenant configs.\n\n### Best practices\n\n1. Keep blueprint and tenant versions monotonic; bump when referenced spec versions change.\n2. Favor stable slot keys (e.g. `dataViews.dashboard`) to align with Studio UX.\n3. Reference telemetry and experiments declared in their respective specs to maintain observability.\n4. Run `resolveAppConfig` in pure unit tests and `composeAppConfig(..., { strict: true })` in CI to catch drift early.\n5. Pair resolved configs with `TestSpec` scenarios to guard tenant experiences end-to-end.\n\n### Static validation\n\nUse the validation helpers in `@contractspec/lib.contracts-spec/app-config/validation` to keep blueprints and tenant configs safe before publish time.\n\n```ts\nimport {\n  validateConfig,\n  validateBlueprint,\n  validateTenantConfig,\n  validateResolvedConfig,\n} from '@contractspec/lib.contracts-spec/app-config/validation';\n\nconst context = {\n  integrationSpecs,\n  tenantConnections,\n  knowledgeSpaces,\n  knowledgeSources,\n  translationCatalogs: {\n    blueprint: blueprintCatalog,\n    platform: platformCatalog,\n  },\n  existingConfigs,\n};\n\nconst blueprintReport = validateBlueprint(blueprint, context);\nconst tenantReport = validateTenantConfig(blueprint, tenant, context);\nconst publishReport = validateConfig(blueprint, tenant, context);\n```\n\n- `ValidationResult` exposes `valid`, plus structured `errors`, `warnings`, and `info`.\n- Core rules cover capability references, integration slot bindings (category/ownership/capabilities), knowledge bindings, branding constraints (domains + assets), and translation coverage.\n- Call `validateBlueprint` in CI when committing new specs, and `validateConfig` before promoting/publishing a tenant config.\n- `validateResolvedConfig` can be used as a runtime pre-flight check when composing full configs for workflows.\n- CLI usage example (blueprint + tenant):\n\n```\nbuncontractspec validate \\\n  packages/examples/integration-stripe/blueprint.ts \\\n  --blueprint packages/examples/integration-stripe/blueprint.ts \\\n  --tenant-config packages/examples/integration-stripe/tenant.ts\n```\n- Repository script:\n\n```\nbun run validate:blueprints\n```\n\nRuns the static validator for the sample blueprints/tenants and is wired into CI.\n\n\n### Lifecycle types & events\n\nTo model multi-step configuration changes, use the lifecycle helpers exported from `@contractspec/lib.contracts-spec/app-config`:\n\n```ts\nimport type {\n  ConfigStatus,\n  TenantAppConfigVersion,\n  ConfigTransition,\n} from '@contractspec/lib.contracts-spec/app-config';\nimport {\n  ConfigDraftCreatedEvent,\n  ConfigPromotedToPreviewEvent,\n  ConfigPublishedEvent,\n  ConfigRolledBackEvent,\n} from '@contractspec/lib.contracts-spec/app-config';\n```\n\n- `ConfigStatus` enumerates the canonical states: `draft`, `preview`, `published`, `archived`, `superseded`.\n- `TenantAppConfigMeta` now includes lifecycle metadata (`status`, `createdBy`, `publishedBy`, `publishedAt`, `rolledBackFrom`, `rolledBackTo`, `changeSummary`).\n- `TenantAppConfigVersion` couples the lifecycle-aware metadata with the `TenantAppConfig` payload for history views.\n- `ConfigTransition` captures state changes with actor, timestamp, and optional reason.\n- Lifecycle events (`app_config.draft_created`, `app_config.promoted_to_preview`, `app_config.published`, `app_config.rolled_back`) standardize observability across services.\n- Lifecycle contract specs (`appConfig.lifecycle.*`) expose typed commands/queries for create \u2192 preview \u2192 publish \u2192 rollback flows.\n\n",
  },
];
registerDocBlocks(tech_contracts_app_config_DocBlocks);
