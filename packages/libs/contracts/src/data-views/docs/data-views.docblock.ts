import type { DocBlock } from '@lssm/lib.contracts/docs';
import { registerDocBlocks } from '../../registry';

export const tech_contracts_data_views_DocBlocks: DocBlock[] = [
  {
    id: "docs.tech.contracts.data-views",
    title: "DataViewSpec Overview",
    summary: "`DataViewSpec` is the declarative contract for projecting entities into list/detail/table/grid experiences. Each spec ties to contract operations (`source.primary`, `source.item`) and describes how the UI should present, sort, and filter records. Host applications use the spec to render UI with shared components (`DataViewRenderer`, `DataViewList`, `DataViewTable`, `DataViewDetail`) while keeping presentation logic in a single source of truth.",
    kind: 'reference',
    visibility: 'public',
    route: "/docs/tech/contracts/data-views",
    tags: ["tech", "contracts", "data-views"],
    body: "# DataViewSpec Overview\n\n## Purpose\n\n`DataViewSpec` is the declarative contract for projecting entities into list/detail/table/grid experiences. Each spec ties to contract operations (`source.primary`, `source.item`) and describes how the UI should present, sort, and filter records. Host applications use the spec to render UI with shared components (`DataViewRenderer`, `DataViewList`, `DataViewTable`, `DataViewDetail`) while keeping presentation logic in a single source of truth.\n\n## Location\n\n- Type definitions and registry: `packages/libs/contracts/src/data-views.ts`\n- React renderers: `packages/libs/design-system/src/components/data-view`\n- CLI scaffolding: `contractspec create --type data-view`\n\n## Schema Highlights\n\n```ts\nexport interface DataViewSpec {\n  meta: DataViewMeta;       // ownership meta + { name, version, entity }\n  source: DataViewSource;   // contract operations and refresh events\n  view: DataViewConfig;     // union of list/detail/table/grid definitions\n  states?: DataViewStates;  // optional empty/error/loading presentations\n  policy?: { flags?: string[]; pii?: string[] };\n}\n```\n\n- **DataViewMeta**: `name`, `version`, `entity`, ownership metadata (title, description, domain, owners, tags, stability).\n- **DataViewSource**:\n  - `primary`: required query operation (`OpRef`) for fetching collections.\n  - `item`: optional detail query (recommended for `detail` views).\n  - `mutations`: optional create/update/delete operation refs.\n  - `refreshEvents`: events that should trigger refresh.\n- **DataViewConfig** (union):\n  - `list`: card/compact list, `primaryField`, `secondaryFields`.\n  - `table`: column configuration (`columns`, alignments, density).\n  - `detail`: sections of fields for record inspection.\n  - `grid`: multi-column grid (rendered as card list today).\n- **DataViewField**: `key`, `label`, `dataPath`, formatting hints (`format`), sort/filter toggles, optional presentation override.\n- **DataViewFilter**: describes filter inputs (search, enum, number, date, boolean).\n- **DataViewAction**: simple declarative actions (`navigation` or `operation`).\n\n## Registry Usage\n\n```ts\nimport { DataViewRegistry } from '@lssm/lib.contracts/data-views';\nimport { ResidentsDataView } from './data-views/residents.data-view';\n\nconst registry = new DataViewRegistry();\nregistry.register(ResidentsDataView);\n\nconst listView = registry.get('residents.admin.list');\n```\n\nRegistries guard against duplicate `(name, version)` pairs and make latest-version lookup trivial.\n\n## Rendering\n\n```tsx\nimport { DataViewRenderer } from '@lssm/lib.design-system';\nimport { ResidentsDataView } from '../contracts/data-views/residents.data-view';\n\nfunction ResidentsTable({ rows }: { rows: Record<string, unknown>[] }) {\n  return (\n    <DataViewRenderer\n      spec={ResidentsDataView}\n      items={rows}\n      onRowClick={(row) => console.log('Selected', row)}\n    />\n  );\n}\n```\n\nFor more control, use specific components:\n\n- `DataViewList` \u2013 friendly cards/rows\n- `DataViewTable` \u2013 tabular presentation with optional header/footers\n- `DataViewDetail` \u2013 two-column grouped layout for record inspection\n\nRenderers rely on the field definitions (`dataPath`, `format`) to extract values and render them consistently.\n\n## CLI Scaffolding\n\n```bash\n# Interactive wizard\ncontractspec create --type data-view\n\n# Generates packages/.../data-views/<name>.data-view.ts\n\n# Optional renderer scaffold\ncontractspec build path/to/<name>.data-view.ts\n# \u2192 produces <name>.renderer.tsx that wraps DataViewRenderer with sensible props\n```\n\nWizard prompts:\n- name (dot notation), version, entity\n- kind (`list`, `table`, `detail`, `grid`)\n- primary query operation (required) and optional item query\n- fields (label, data path, format, sorting/filtering)\n\n## Authoring Guidelines\n\n1. **Separation of data & presentation**: keep fetching logic inside contract operations; DataViewSpec only references them via `source`.\n2. **Versioning**: bump `meta.version` when field membership, ordering, or semantics change.\n3. **Consistency**: reuse common field keys across modules to enable shared renderers and filters.\n4. **States**: reference `PresentationRef` for empty/error/loader states to ensure consistent UX.\n5. **Actions**: prefer referencing contract operations instead of embedding business logic in the UI.\n\n## Roadmap\n\n- Derived filters from `fields.filterable` (auto-generated UI).\n- Table density presets per platform.\n- Bridge to PolicySpec for field-level visibility (Phase 2 policy expansion).\n- Automated docs/LLM sync via CLI.\n\n",
  },
];
registerDocBlocks(tech_contracts_data_views_DocBlocks);