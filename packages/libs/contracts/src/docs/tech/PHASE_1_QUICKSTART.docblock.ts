import type { DocBlock } from '@lssm/lib.contracts/docs';
import { registerDocBlocks } from '../registry';

export const tech_PHASE_1_QUICKSTART_DocBlocks: DocBlock[] = [
  {
    id: "docs.tech.PHASE_1_QUICKSTART",
    title: "Phase 1: API Reference Index",
    summary: "Quick reference for all new Phase 1 APIs.",
    kind: 'reference',
    visibility: 'public',
    route: "/docs/tech/PHASE_1_QUICKSTART",
    tags: ["tech", "PHASE_1_QUICKSTART"],
    body: "# Phase 1: API Reference Index\n\nQuick reference for all new Phase 1 APIs.\n\n---\n\n## @lssm/lib.multi-tenancy\n\n### RLS\n```typescript\nimport { createRlsMiddleware, type TenantIdProvider } from '@lssm/lib.multi-tenancy/rls';\n```\n\n### Provisioning\n```typescript\nimport { \n  TenantProvisioningService,\n  type CreateTenantInput,\n  type TenantProvisioningConfig \n} from '@lssm/lib.multi-tenancy/provisioning';\n```\n\n### Isolation\n```typescript\nimport { IsolationValidator } from '@lssm/lib.multi-tenancy/isolation';\n```\n\n---\n\n## @lssm/lib.observability\n\n### Tracing\n```typescript\nimport { \n  getTracer,\n  traceAsync,\n  traceSync,\n  createTracingMiddleware \n} from '@lssm/lib.observability/tracing';\n```\n\n### Metrics\n```typescript\nimport {\n  getMeter,\n  createCounter,\n  createUpDownCounter,\n  createHistogram,\n  standardMetrics\n} from '@lssm/lib.observability/metrics';\n```\n\n### Logging\n```typescript\nimport {\n  Logger,\n  logger,\n  type LogLevel,\n  type LogEntry\n} from '@lssm/lib.observability/logging';\n```\n\n---\n\n## @lssm/lib.resilience\n\n### Circuit Breaker\n```typescript\nimport {\n  CircuitBreaker,\n  type CircuitState,\n  type CircuitBreakerConfig\n} from '@lssm/lib.resilience/circuit-breaker';\n```\n\n### Retry\n```typescript\nimport { retry } from '@lssm/lib.resilience/retry';\n```\n\n### Timeout\n```typescript\nimport { timeout } from '@lssm/lib.resilience/timeout';\n```\n\n### Fallback\n```typescript\nimport { fallback } from '@lssm/lib.resilience/fallback';\n```\n\n---\n\n## Enhanced: @lssm/lib.contracts\n\n### DataViews\n```typescript\nimport { DataViewQueryGenerator } from '@lssm/lib.contracts/data-views/query-generator';\nimport { DataViewRuntime } from '@lssm/lib.contracts/data-views/runtime';\n```\n\n### Workflows\n```typescript\nimport { SLAMonitor, type SLABreachEvent } from '@lssm/lib.contracts/workflow/sla-monitor';\nimport { PrismaStateStore } from '@lssm/lib.contracts/workflow/adapters/db-adapter';\n```\n\n---\n\n## Enhanced: @lssm/lib.design-system\n\n### DataView Components\n```typescript\nimport { DataViewRenderer } from '@lssm/lib.design-system/components/data-view/DataViewRenderer';\n// Also available: DataViewList, DataViewTable, DataViewDetail\n```\n\n---\n\n## Usage Examples\n\n### Complete Workflow with All Features\n\n```typescript\nimport { WorkflowRunner } from '@lssm/lib.contracts/workflow/runner';\nimport { PrismaStateStore } from '@lssm/lib.contracts/workflow/adapters/db-adapter';\nimport { SLAMonitor } from '@lssm/lib.contracts/workflow/sla-monitor';\nimport { CircuitBreaker } from '@lssm/lib.resilience/circuit-breaker';\nimport { traceAsync } from '@lssm/lib.observability/tracing';\n\nconst runner = new WorkflowRunner({\n  registry,\n  stateStore: new PrismaStateStore(db),\n  opExecutor: async (op, input, ctx) => {\n    return traceAsync(`op.${op.name}`, async (span) => {\n      span.setAttribute('operation', op.name);\n      const breaker = getCircuitBreaker(op.name);\n      return breaker.execute(() => executeOperation(op, input, ctx));\n    });\n  },\n  eventEmitter: (event, payload) => {\n    if (event.startsWith('workflow.')) {\n      logger.info(event, payload);\n    }\n  },\n});\n\nconst monitor = new SLAMonitor((event, payload) => {\n  logger.warn('SLA_BREACH', payload);\n  alertOps(payload);\n});\n\n// Start workflow\nconst workflowId = await runner.start('payment.flow', 1);\n\n// Monitor SLA\nconst state = await runner.getState(workflowId);\nconst spec = registry.get('payment.flow', 1);\nmonitor.check(state, spec!);\n```\n\n### Complete DataView with Observability\n\n```typescript\nimport { DataViewRenderer } from '@lssm/lib.design-system';\nimport { DataViewQueryGenerator } from '@lssm/lib.contracts/data-views/query-generator';\nimport { traceAsync } from '@lssm/lib.observability/tracing';\nimport { MyDataView } from './specs/users.data-view';\n\nexport function UserListPage() {\n  const [page, setPage] = useState(1);\n  const [users, setUsers] = useState([]);\n\n  const loadUsers = async () => {\n    return traceAsync('load_users', async (span) => {\n      const generator = new DataViewQueryGenerator(MyDataView);\n      const query = generator.generate({ pagination: { page, pageSize: 20 } });\n      \n      span.setAttribute('page', page);\n      const result = await api.execute(query);\n      setUsers(result.data);\n    });\n  };\n\n  return (\n    <DataViewRenderer\n      spec={MyDataView}\n      items={users}\n      pagination={{ page, pageSize: 20, total: users.length }}\n      onPageChange={setPage}\n    />\n  );\n}\n```\n\n### Complete Multi-Tenant Setup\n\n```typescript\n// 1. RLS Middleware\nimport { createRlsMiddleware } from '@lssm/lib.multi-tenancy/rls';\ndb.$use(createRlsMiddleware(() => req.tenantId));\n\n// 2. Tenant Provisioning\nimport { TenantProvisioningService } from '@lssm/lib.multi-tenancy/provisioning';\nconst service = new TenantProvisioningService({ db });\n\n// 3. Create new tenant\nawait service.provision({\n  id: 'acme',\n  name: 'Acme Corp',\n  slug: 'acme',\n  ownerEmail: 'admin@acme.com',\n});\n\n// 4. Validate isolation in tests\nimport { IsolationValidator } from '@lssm/lib.multi-tenancy/isolation';\n\ntest('queries are isolated', () => {\n  const isValid = IsolationValidator.validateQuery(\n    'User',\n    'findMany',\n    { where: { tenantId: 'acme' } },\n    'acme'\n  );\n  expect(isValid).toBe(true);\n});\n```\n\n---\n\n## Testing\n\n### Test Circuit Breakers\n\n```typescript\nimport { CircuitBreaker } from '@lssm/lib.resilience/circuit-breaker';\n\ntest('circuit opens after threshold', async () => {\n  const breaker = new CircuitBreaker({\n    failureThreshold: 3,\n    resetTimeoutMs: 5000,\n  });\n\n  // Trigger failures\n  for (let i = 0; i < 3; i++) {\n    await expect(\n      breaker.execute(() => Promise.reject('error'))\n    ).rejects.toThrow();\n  }\n\n  // Circuit should be open\n  await expect(\n    breaker.execute(() => Promise.resolve('ok'))\n  ).rejects.toThrow('CircuitBreaker is OPEN');\n});\n```\n\n### Test Workflow Retry\n\n```typescript\ntest('workflow retries on failure', async () => {\n  let attempts = 0;\n  const opExecutor = async () => {\n    attempts++;\n    if (attempts < 3) throw new Error('fail');\n    return 'success';\n  };\n\n  const runner = new WorkflowRunner({ /* ... */ opExecutor });\n  await runner.executeStep(workflowId);\n  \n  expect(attempts).toBe(3);\n});\n```\n\n---\n\n## Common Patterns\n\n### Pattern: Resilient External Call\n\n```typescript\nimport { CircuitBreaker } from '@lssm/lib.resilience/circuit-breaker';\nimport { retry } from '@lssm/lib.resilience/retry';\nimport { timeout } from '@lssm/lib.resilience/timeout';\nimport { traceAsync } from '@lssm/lib.observability/tracing';\n\nconst breaker = new CircuitBreaker({ failureThreshold: 5, resetTimeoutMs: 30000 });\n\nexport async function callExternalAPI(input: any) {\n  return traceAsync('external_api_call', async (span) => {\n    span.setAttribute('service', 'stripe');\n    \n    return breaker.execute(() =>\n      retry(\n        () => timeout(() => stripe.api.call(input), 5000),\n        3,\n        1000,\n        true\n      )\n    );\n  });\n}\n```\n\n**Benefits**: Circuit breaker + retry + timeout + tracing in one place.\n\n---\n\n### Pattern: Tenant-Aware Operation\n\n```typescript\nimport { traceAsync } from '@lssm/lib.observability/tracing';\n\nexport async function listUsers(tenantId: string) {\n  return traceAsync('list_users', async (span) => {\n    span.setAttribute('tenant_id', tenantId);\n    \n    // RLS middleware will inject WHERE tenantId = ?\n    return db.user.findMany();\n  });\n}\n```\n\n---\n\n### Pattern: Monitored Workflow\n\n```typescript\nimport { WorkflowRunner } from '@lssm/lib.contracts/workflow/runner';\nimport { SLAMonitor } from '@lssm/lib.contracts/workflow/sla-monitor';\nimport { logger } from '@lssm/lib.observability/logging';\n\nconst monitor = new SLAMonitor((event, payload) => {\n  logger.warn('workflow.sla_breach', payload);\n});\n\n// In workflow poller\nconst state = await runner.getState(workflowId);\nconst spec = registry.get(state.workflowName, state.workflowVersion);\nif (spec) {\n  monitor.check(state, spec);\n}\n```\n\n---\n\n## Next Steps\n\n1. **Implement one quick win** (30 minutes)\n2. **Add tests for new functionality** (1 hour)\n3. **Deploy to staging and verify observability** (1 hour)\n4. **Roll out to production** (monitor closely)\n5. **Read full documentation** at https://contractspec.lssm.tech/docs\n\n---\n\n**Questions?** See `/docs/guides/phase-1-migration` or reach out via https://contractspec.lssm.tech/contact\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
  },
];
registerDocBlocks(tech_PHASE_1_QUICKSTART_DocBlocks);