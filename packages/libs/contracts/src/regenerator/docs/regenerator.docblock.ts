import type { DocBlock } from '@contractspec/lib.contracts/docs';
import { registerDocBlocks } from '../../docs/registry';

export const tech_contracts_regenerator_DocBlocks: DocBlock[] = [
  {
    id: 'docs.tech.contracts.regenerator',
    title: 'Regenerator Service',
    summary:
      'The Regenerator daemon observes telemetry, error, and behavior streams, then suggests spec-level changes (not code patches) that can be reviewed and applied through the App Studio.',
    kind: 'reference',
    visibility: 'public',
    route: '/docs/tech/contracts/regenerator',
    tags: ['tech', 'contracts', 'regenerator'],
    body: "## Regenerator Service\n\nThe Regenerator daemon observes telemetry, error, and behavior streams, then suggests spec-level changes (not code patches) that can be reviewed and applied through the App Studio.\n\n- Runtime entrypoint: `packages/libs/contracts/src/regenerator/service.ts`\n- Types/interfaces: `packages/libs/contracts/src/regenerator/types.ts`\n- Signal adapters: `packages/libs/contracts/src/regenerator/adapters.ts`\n\n### Architecture\n\n```text\nSignal Adapters \u2500\u2500\u25ba RegeneratorService \u2500\u2500\u25ba Rules \u2500\u2500\u25ba ProposalSink\n          \u25b2                                       \u2502\n          \u2502                                       \u25bc\n     Telemetry / Errors / Behavior         Spec change proposals\n```\n\n1. **Signal adapters** pull batches of telemetry, error logs, or behavior metrics for each `RegenerationContext`.\n2. `RegeneratorService` schedules polling (`resolveAppConfig` + `composeAppConfig` provide context).\n3. **Rules** implement domain heuristics and emit `SpecChangeProposal` objects.\n4. **Proposal sinks** persist or forward proposals for human review.\n\n### Key types\n\n```ts\nexport interface RegenerationContext {\n  id: string;\n  blueprint: AppBlueprintSpec;\n  tenantConfig: TenantAppConfig;\n  resolved: ResolvedAppConfig;\n}\n\nexport interface RegeneratorRule {\n  id: string;\n  description: string;\n  evaluate(\n    context: RegenerationContext,\n    signals: RegeneratorSignal[]\n  ): Promise<SpecChangeProposal[]>;\n}\n\nexport interface SpecChangeProposal {\n  id: string;\n  title: string;\n  summary: string;\n  confidence: 'low' | 'medium' | 'high';\n  target: ProposalTarget;\n  actions: ProposalAction[];\n  blockers?: ProposalBlocker[];\n  signalIds: string[];\n  createdAt: Date;\n}\n```\n\n- Signals are normalized envelopes: telemetry (`count`, anomaly score), errors, and behavior trends.\n- Proposals reference blueprint or tenant specs via `ProposalTarget`.\n- Actions encode what the automation should perform (update blueprint, run tests/migrations, trigger regeneration).\n\n### Providing signals\n\nImplement `TelemetrySignalProvider`, `ErrorSignalProvider`, or `BehaviorSignalProvider`:\n\n```ts\nconst service = new RegeneratorService({\n  contexts,\n  adapters: {\n    telemetry: new PosthogTelemetryAdapter(),\n    errors: new SentryErrorAdapter(),\n  },\n  rules: [new WorkflowFailureRule(), new DataViewUsageRule()],\n  sink: new ProposalQueueSink(),\n  pollIntervalMs: 60_000,\n});\n```\n\nAdapters receive the full `RegenerationContext`, making it easy to scope queries per tenant/app.\n\n### Authoring rules\n\nRules focus on signals \u2192 proposals:\n\n```ts\nclass WorkflowFailureRule implements RegeneratorRule {\n  id = 'workflow-failure';\n  description = 'Suggest splitting workflows that exceed failure thresholds';\n\n  async evaluate(context, signals) {\n    const failures = signals.filter(\n      (signal) =>\n        signal.type === 'telemetry' &&\n        signal.signal.eventName === 'workflow.failure' &&\n        signal.signal.count >= 10\n    );\n\n    if (failures.length === 0) return [];\n\n    return [\n      {\n        id: `${this.id}-${context.id}`,\n        title: 'Split onboarding workflow',\n        summary: 'Step 3 fails consistently; propose dedicated remediation branch.',\n        confidence: 'medium',\n        rationale: ['Failure count \u2265 10 within last window'],\n        target: {\n          specType: 'workflow',\n          reference: { name: 'onboarding.workflow', version: '1.0.0' },\n          tenantScoped: true,\n        },\n        actions: [\n          { kind: 'update_tenant_config', summary: 'Add alternate fallback path' },\n          { kind: 'run_tests', tests: ['workflows/onboarding.spec.ts'] },\n        ],\n        signalIds: failures.map((f) => f.signal.eventName),\n        createdAt: new Date(),\n      },\n    ];\n  }\n}\n```\n\n### Reviewing proposals\n\nProposals flow to a `ProposalSink` (queue, DB, messaging bus). The Studio will surface:\n\n1. Signal evidence (telemetry counts, error metadata)\n2. Proposed spec diffs and required actions (tests/migrations)\n3. Approval workflow (approve \u2192 write spec diff \u2192 run automation)\n\n### CLI driver\n\nRun the regenerator daemon from the CLI:\n\n```bash\nbunx contracts regenerator ./app.blueprint.ts ./tenant.config.ts ./regenerator.rules.ts auto \\\n  --executor ./regenerator.executor.ts \\\n  --poll-interval 60000 \\\n  --batch-duration 300000 \\\n  --dry-run\n```\n\n- Expects modules exporting default `AppBlueprintSpec`, `TenantAppConfig`, and one or more `RegenerationRule`s.\n- Pass a sink module path, or use the special `auto` value with `--executor <module>` to instantiate an `ExecutorProposalSink`.\n- Executor modules can export a `ProposalExecutor` instance, a factory, or a plain dependency object for the executor constructor. Optional exports: `sinkOptions`, `logger`, `onResult`, `dryRun`.\n- Optionally provide `--contexts ./contexts.ts` to load custom context arrays (advanced multi-tenant scenarios).\n- Use `--dry-run` to preview actions without mutating specs/configs, and `--once` for CI smoke tests.\n\n### Proposal executor\n\n`ProposalExecutor` + `ExecutorProposalSink` orchestrate follow-up actions once a proposal is approved:\n\n- Interfaces for applying blueprint or tenant-config updates (`BlueprintUpdater`, `TenantConfigUpdater`).\n- Hooks for running contract tests and migrations (`TestExecutor`, `MigrationExecutor`).\n- Optional trigger to recompose the runtime (`RegenerationTrigger`).\n- Built-in `dryRun` mode to preview outcomes.\n- Pluggable result logging/forwarding via `ExecutorSinkOptions`.\n\n```ts\nimport {\n  ProposalExecutor,\n  ExecutorProposalSink,\n} from '@contractspec/lib.contracts/regenerator';\n\nconst executor = new ProposalExecutor({\n  tenantConfigUpdater,\n  testExecutor,\n  migrationExecutor,\n  regenerationTrigger,\n});\n\nconst sink = new ExecutorProposalSink(executor, {\n  dryRun: false,\n  onResult: ({ result }) => console.log(result.status),\n});\n```\n\nExecution results include per-action status (`success`, `skipped`, `failed`) plus aggregated proposal status (`success`, `partial`, `failed`). Missing dependencies mark actions as `skipped`, making it easy to plug into partial automation flows today and extend later.\n\n### Next steps\n\n- Build adapters for existing telemetry/error providers.\n- Encode canonical rules (workflow failure, feature under-use, high latency).\n- Integrate with App Studio proposal inbox and automate acceptance (write spec diff, run tests, queue migrations).\n\n",
  },
];
registerDocBlocks(tech_contracts_regenerator_DocBlocks);
