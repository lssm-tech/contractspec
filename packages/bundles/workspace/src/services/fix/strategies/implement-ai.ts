/**
 * Implement AI strategy.
 *
 * Creates a spec with AI-generated content using experimental stability.
 */

import type {
  FixableIssue,
  FixOptions,
  FixResult,
  FixFileChange,
  SpecGenerationContext,
} from '../types';
import type { FsAdapter } from '../../../ports/fs';
import type { LoggerAdapter } from '../../../ports/logger';
import { FIX_STRATEGY_STABILITY } from '../types';
import {
  generateSkeletonOperation,
  generateSkeletonEvent,
  generateSkeletonPresentation,
} from '../../../templates/fix';
import path from 'node:path';

/**
 * Create a spec with AI-generated content.
 *
 * Falls back to skeleton if AI is not available or fails.
 */
export async function implementAiStrategy(
  issue: FixableIssue,
  options: FixOptions,
  adapters: { fs: FsAdapter; logger: LoggerAdapter }
): Promise<FixResult> {
  const { fs, logger } = adapters;
  const { ref, specType, featureKey } = issue;

  try {
    // Build generation context with AI enrichment
    const ctx: SpecGenerationContext = {
      key: ref.key,
      version: ref.version,
      specType,
      stability: FIX_STRATEGY_STABILITY['implement-ai'],
      featureKey,
    };

    // Try to get AI-generated content
    let enrichedCtx = ctx;
    if (options.aiConfig) {
      try {
        enrichedCtx = await enrichWithAI(ctx, options, logger);
      } catch (aiError) {
        logger.warn('AI enrichment failed, falling back to skeleton', {
          error: aiError instanceof Error ? aiError.message : String(aiError),
        });
        // Continue with unenriched context
      }
    } else {
      logger.info('No AI config provided, using skeleton with experimental stability');
    }

    // Generate the spec code
    const code = generateSpecCode(enrichedCtx);
    if (!code) {
      return {
        success: false,
        strategy: 'implement-ai',
        issue,
        filesChanged: [],
        error: `Unsupported spec type: ${specType}`,
      };
    }

    // Determine output path
    const filePath = resolveOutputPath(ref.key, specType, options);

    const filesChanged: FixFileChange[] = [];

    // Write the file (unless dry run)
    if (!options.dryRun) {
      // Ensure directory exists
      const dir = path.dirname(filePath);
      await fs.mkdir(dir);

      // Write the spec file
      await fs.writeFile(filePath, code);

      filesChanged.push({
        path: filePath,
        action: 'created',
      });
    } else {
      // For dry run, report what would be created
      filesChanged.push({
        path: filePath,
        action: 'created',
      });
    }

    return {
      success: true,
      strategy: 'implement-ai',
      issue,
      filesChanged,
    };
  } catch (error) {
    return {
      success: false,
      strategy: 'implement-ai',
      issue,
      filesChanged: [],
      error: error instanceof Error ? error.message : String(error),
    };
  }
}

/**
 * Enrich the generation context with AI-generated content.
 */
async function enrichWithAI(
  ctx: SpecGenerationContext,
  options: FixOptions,
  logger: LoggerAdapter
): Promise<SpecGenerationContext> {
  // TODO: Integrate with existing AIGenerator from services/create/ai-generator.ts
  // For now, generate reasonable defaults based on the key

  logger.info('Generating AI content for spec', { key: ctx.key, type: ctx.specType });

  const enrichment = inferEnrichmentFromKey(ctx.key, ctx.specType);

  return {
    ...ctx,
    description: enrichment.description,
    enrichment: {
      goal: enrichment.goal,
      context: enrichment.context,
      owners: ['@team'],
      tags: enrichment.tags,
    },
  };
}

/**
 * Infer enrichment content from the spec key.
 */
function inferEnrichmentFromKey(
  key: string,
  specType: string
): {
  description: string;
  goal: string;
  context: string;
  tags: string[];
} {
  const parts = key.split('.');
  const domain = parts[0] || 'unknown';
  const action = parts.slice(1).join(' ').replace(/_/g, ' ');

  const domainTags = [domain];
  const actionKeywords = action.toLowerCase().split(' ');

  // Add relevant tags based on action keywords
  const tagKeywords = ['auth', 'user', 'admin', 'api', 'data', 'search', 'create', 'update', 'delete'];
  const matchedTags = tagKeywords.filter((tag) =>
    actionKeywords.some((kw) => kw.includes(tag))
  );

  return {
    description: `${capitalize(specType)} for ${domain} ${action}`,
    goal: `Enable ${action} functionality in the ${domain} domain`,
    context: `Part of the ${domain} feature set. Generated by ContractSpec AI fix.`,
    tags: [...domainTags, ...matchedTags],
  };
}

/**
 * Generate spec code based on type.
 */
function generateSpecCode(ctx: SpecGenerationContext): string | undefined {
  switch (ctx.specType) {
    case 'operation':
      return generateSkeletonOperation(ctx);
    case 'event':
      return generateSkeletonEvent(ctx);
    case 'presentation':
      return generateSkeletonPresentation(ctx);
    default:
      return undefined;
  }
}

/**
 * Resolve the output file path for a new spec.
 */
function resolveOutputPath(
  key: string,
  specType: string,
  options: FixOptions
): string {
  const baseDir = options.outputDir || options.workspaceRoot;

  // Convert key to file name: "docs.search" -> "docs-search"
  const fileName = key.replace(/\./g, '-').toLowerCase();

  // Get file extension based on spec type
  const extension = getFileExtension(specType);

  // Determine subdirectory based on spec type
  const subDir = getSubDirectory(specType);

  return path.join(baseDir, subDir, `${fileName}${extension}`);
}

/**
 * Get file extension for a spec type.
 */
function getFileExtension(specType: string): string {
  const extensions: Record<string, string> = {
    operation: '.contracts.ts',
    event: '.event.ts',
    presentation: '.presentation.ts',
    workflow: '.workflow.ts',
    'data-view': '.data-view.ts',
    form: '.form.ts',
    migration: '.migration.ts',
    experiment: '.experiment.ts',
    capability: '.capability.ts',
  };

  return extensions[specType] || '.ts';
}

/**
 * Get subdirectory for a spec type.
 */
function getSubDirectory(specType: string): string {
  const dirs: Record<string, string> = {
    operation: 'operations',
    event: 'events',
    presentation: 'presentations',
    workflow: 'workflows',
    'data-view': 'data-views',
    form: 'forms',
    migration: 'migrations',
    experiment: 'experiments',
    capability: 'capabilities',
  };

  return dirs[specType] || 'specs';
}

/**
 * Capitalize the first letter of a string.
 */
function capitalize(str: string): string {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
