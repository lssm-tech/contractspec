import path from 'path';
import {
  defaultDocRegistry,
  type DocBlock,
} from '@contractspec/lib.contracts/docs';
import {
  convertSpecToDocBlock,
  loadSpecFromSource,
  scanAllSpecsFromSource,
  scanSpecSource,
  type SpecScanResult,
} from '@contractspec/module.workspace';
import type { WorkspaceAdapters } from '../../ports/logger';
import { ModuleResolver } from '../modules/module-resolver';

export interface DocsServiceOptions {
  outputDir?: string;
  format?: 'markdown' | 'html' | 'json';
  rootPath?: string;
}

export interface DocsServiceResult {
  blocks: DocBlock[];
  count: number;
}

/**
 * Generate documentation from spec files.
 */
export async function generateDocsFromSpecs(
  specFiles: string[],
  options: DocsServiceOptions,
  adapters: WorkspaceAdapters
): Promise<DocsServiceResult> {
  const { fs, logger } = adapters;
  const blocks: DocBlock[] = [];

  logger.info(`Generating docs for ${specFiles.length} files...`);

  if (options.outputDir) {
    await fs.mkdir(options.outputDir);
  }

  // Initialize ModuleResolver
  const resolver = new ModuleResolver(adapters);
  // 1. Scan all specs to build the module index
  const scanResults: SpecScanResult[] = [];
  for (const file of specFiles) {
    try {
      const content = await fs.readFile(file);
      const results = scanAllSpecsFromSource(content, file);
      if (results.length > 0) {
        scanResults.push(...results);
      } else {
        // Fallback if no multi-specs found, try single scan logic
        const single = scanSpecSource(content, file);
        if (single.specType !== 'unknown') {
          scanResults.push(single);
        }
      }
    } catch (_err) {
      // ignore read errors
    }
  }

  resolver.initialize(scanResults);

  for (const file of specFiles) {
    try {
      const parsedList = await loadSpecFromSource(file);

      if (parsedList && parsedList.length > 0) {
        for (const parsed of parsedList) {
          const block = convertSpecToDocBlock(parsed, {
            rootPath: options.rootPath,
          });
          // Register in global registry
          defaultDocRegistry.register(block);
          blocks.push(block);
          logger.debug(`Generated doc for ${block.id}`);

          if (options.outputDir) {
            // Determine grouping based on module resolution
            const moduleDef = resolver.resolve(file);
            let targetDir = options.outputDir;

            if (moduleDef) {
              targetDir = path.join(options.outputDir, moduleDef.key);
            } else {
              targetDir = path.join(options.outputDir, '_common'); // Fallback for root-level specs
            }

            // Ensure subdirectory exists
            await fs.mkdir(targetDir);

            // Flattened structure: [module]/[docId].md
            const filename = `${block.id}.md`;
            const filePath = path.join(targetDir, filename);
            if (filePath.includes('defineAppConfig')) {
              console.log(
                'Alert error founddddd',
                parsedList.map((f) => f.filePath)
              );
            }
            const generatedContent = `<!-- @generated - This file was generated by ContractSpec. Do not edit manually. -->\n\n${block.body}`;
            await fs.writeFile(filePath, generatedContent);
          }
        }
      } else {
        logger.warn(`Could not parse spec from ${file}`);
      }
    } catch (error) {
      logger.error(
        `Error processing ${file}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  if (options.outputDir) {
    logger.info(`Wrote ${blocks.length} doc files to ${options.outputDir}`);
  }

  return { blocks, count: blocks.length };
}
