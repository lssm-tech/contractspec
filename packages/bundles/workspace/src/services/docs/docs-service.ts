import path from 'path';
import {
  defaultDocRegistry,
  type DocBlock,
} from '@contractspec/lib.contracts/docs';
import {
  convertSpecToDocBlock,
  loadSpecFromSource,
  scanAllSpecsFromSource,
  scanSpecSource,
  type SpecScanResult,
} from '@contractspec/module.workspace';
import type { WorkspaceAdapters } from '../../ports/logger';
import { ModuleResolver } from '../modules/module-resolver';

export interface DocsServiceOptions {
  outputDir?: string;
  format?: 'markdown' | 'html' | 'json';
  rootPath?: string;
}

export interface DocsServiceResult {
  blocks: DocBlock[];
  count: number;
}

/**
 * Generate documentation from spec files.
 */
export async function generateDocsFromSpecs(
  specFiles: string[],
  options: DocsServiceOptions,
  adapters: WorkspaceAdapters
): Promise<DocsServiceResult> {
  const { fs, logger } = adapters;
  const blocks: DocBlock[] = [];

  logger.info(`Generating docs for ${specFiles.length} files...`);

  if (options.outputDir) {
    await fs.mkdir(options.outputDir);
  }

  // Initialize ModuleResolver
  const resolver = new ModuleResolver(adapters);
  // 1. Scan all specs to build the module index
  const scanResults: SpecScanResult[] = [];
  for (const file of specFiles) {
    try {
      const content = await fs.readFile(file);
      if (file.endsWith('packages/libs/contracts/src/app-config/spec.ts')) {
        console.log('coupable', file);
      }
      const results = scanAllSpecsFromSource(content, file);
      if (results.length > 0) {
        if (
          results.some((r) =>
            r.filePath.endsWith(
              'packages/libs/contracts/src/app-config/spec.ts'
            )
          )
        ) {
          console.log('coupable 2', file, results);
        }
        scanResults.push(...results);
      } else {
        // Fallback if no multi-specs found, try single scan logic
        const single = scanSpecSource(content, file);
        if (
          single.filePath.endsWith(
            'packages/libs/contracts/src/app-config/spec.ts'
          )
        ) {
          console.log('coupable 3', file, single);
        }
        if (single.specType !== 'unknown') {
          scanResults.push(single);
        }
      }
    } catch (_err) {
      // ignore read errors
    }
  }

  resolver.initialize(scanResults);

  for (const file of specFiles) {
    try {
      const parsedList = await loadSpecFromSource(file);

      if (!parsedList?.length) {
        logger.warn(`Could not parse spec from ${file}`);
        continue;
      }

      for (const parsed of parsedList) {
        const block = convertSpecToDocBlock(parsed, {
          rootPath: options.rootPath,
        });
        // Register in global registry
        defaultDocRegistry.register(block);
        blocks.push(block);
        logger.debug(`Generated doc for ${block.id}`);

        if (!options.outputDir) {
          continue;
        }

        // Determine grouping based on module resolution
        const moduleDef = resolver.resolve(file);
        let targetDir = options.outputDir;

        if (moduleDef) {
          if (moduleDef.key === 'defineAppConfig')
            console.warn(`Here`, moduleDef, parsed.filePath);
          targetDir = path.join(options.outputDir, moduleDef.key);
        } else {
          targetDir = path.join(options.outputDir, '_common'); // Fallback for root-level specs
        }

        // Ensure subdirectory exists
        await fs.mkdir(targetDir);

        // Flattened structure: [module]/[docId].md
        const filename = `${block.id}.md`;
        const filePath = path.join(targetDir, filename);
        if (filePath.includes('app-config')) {
          console.log('Alert app-config', filePath, parsed.filePath);
        }
        if (filePath.includes('defineAppConfig')) {
          console.log('Alert defineAppConfig', filePath, parsed.filePath);
        }
        const generatedContent = `<!-- @generated - This file was generated by ContractSpec. Do not edit manually. -->\n\n${block.body}`;
        await fs.writeFile(filePath, generatedContent);
      }
    } catch (error) {
      logger.error(
        `Error processing ${file}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  if (options.outputDir) {
    logger.info(`Wrote ${blocks.length} doc files to ${options.outputDir}`);
  }

  return { blocks, count: blocks.length };
}
