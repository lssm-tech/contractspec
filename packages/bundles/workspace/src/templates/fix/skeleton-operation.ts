/**
 * Skeleton operation template.
 *
 * Generates a minimal operation spec stub with in_creation stability.
 */

import type { SpecGenerationContext } from '../../services/fix/types';

/**
 * Convert a string to PascalCase.
 */
function toPascalCase(str: string): string {
  return str
    .split(/[-_.]/)
    .map((s) => s.charAt(0).toUpperCase() + s.slice(1))
    .join('');
}

/**
 * Infer operation kind from key name.
 */
function inferOpKind(key: string): 'command' | 'query' {
  const lowerKey = key.toLowerCase();
  const queryPatterns = [
    'get',
    'list',
    'search',
    'find',
    'fetch',
    'read',
    'query',
    'browse',
    'view',
    'show',
    'navigate',
  ];

  for (const pattern of queryPatterns) {
    if (lowerKey.includes(pattern)) {
      return 'query';
    }
  }

  return 'command';
}

/**
 * Generate a minimal operation spec skeleton.
 */
export function generateSkeletonOperation(ctx: SpecGenerationContext): string {
  const namePart = ctx.key.split('.').pop() || 'Unknown';
  const specVarName = toPascalCase(namePart) + 'Spec';
  const inputSchemaName = specVarName.replace('Spec', 'Input');
  const outputSchemaName = specVarName.replace('Spec', 'Output');
  const opKind = inferOpKind(ctx.key);
  const defineFunc = opKind === 'query' ? 'defineQuery' : 'defineCommand';

  const owners = ctx.enrichment?.owners?.length
    ? ctx.enrichment.owners.map((o) => `'${o}'`).join(', ')
    : "'@team'";

  const tags = ctx.enrichment?.tags?.length
    ? ctx.enrichment.tags.map((t) => `'${t}'`).join(', ')
    : '';

  const description =
    ctx.description || `TODO: Add description for ${ctx.key}`;
  const goal = ctx.enrichment?.goal || 'TODO: Define the business goal';
  const context = ctx.enrichment?.context || 'TODO: Provide context';

  return `/**
 * Operation: ${ctx.key}
 *
 * Skeleton spec generated by ContractSpec fix command.
 * Status: in_creation - Requires implementation
 *
 * Referenced by feature: ${ctx.featureKey || 'unknown'}
 */

import { ${defineFunc} } from '@contractspec/lib.contracts';
import { ScalarTypeEnum, SchemaModel } from '@contractspec/lib.schema';

// TODO: Define input schema
export const ${inputSchemaName} = new SchemaModel({
  name: '${inputSchemaName}',
  description: 'Input for ${ctx.key}',
  fields: {
    // Add your input fields here
    // example: { type: ScalarTypeEnum.String_unsecure(), isOptional: false },
  },
});

// TODO: Define output schema
export const ${outputSchemaName} = new SchemaModel({
  name: '${outputSchemaName}',
  description: 'Output for ${ctx.key}',
  fields: {
    // Add your output fields here
    ok: { type: ScalarTypeEnum.Boolean(), isOptional: false },
  },
});

export const ${specVarName} = ${defineFunc}({
  meta: {
    key: '${ctx.key}',
    version: '${ctx.version}',
    stability: '${ctx.stability}',
    owners: [${owners}],
    tags: [${tags}],
    description: '${description}',
    goal: '${goal}',
    context: '${context}',
  },

  io: {
    input: ${inputSchemaName},
    output: ${outputSchemaName},
    errors: {
      // TODO: Define possible errors
      // EXAMPLE_ERROR: {
      //   description: 'Example error description',
      //   http: 400,
      //   when: 'When this error occurs',
      // },
    },
  },

  policy: {
    auth: 'user',
    // flags: [],
  },

  sideEffects: {
    // emits: [],
    analytics: [],
  },

  transport: {
    rest: { method: '${opKind === 'command' ? 'POST' : 'GET'}' },
    gql: { field: '${ctx.key.replace(/\./g, '_')}' },
    mcp: { toolName: '${ctx.key}.v${ctx.version}' },
  },

  acceptance: {
    scenarios: [
      {
        name: 'TODO: Define happy path',
        given: ['preconditions'],
        when: ['action taken'],
        then: ['expected outcome'],
      },
    ],
    examples: [],
  },
});
`;
}
